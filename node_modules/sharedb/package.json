{
  "name": "sharedb",
  "version": "0.11.35",
  "description": "JSON OT database backend",
  "main": "lib/index.js",
  "dependencies": {
    "arraydiff": "^0.1.1",
    "async": "^1.4.2",
    "deep-is": "^0.1.3",
    "hat": "0.0.3",
    "ot-json0": "^1.0.1",
    "rich-text": "^3.0.0"
  },
  "devDependencies": {
    "coveralls": "^2.11.8",
    "expect.js": "^0.3.1",
    "istanbul": "^0.4.2",
    "mocha": "^2.3.3"
  },
  "scripts": {
    "test": "mocha",
    "test-cover": "node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:FTAndy/sharedb.git"
  },
  "author": {
    "name": "Nate Smith and Joseph Gentle"
  },
  "license": "MIT",
  "gitHead": "c28a1c233ab3a278edb144da27c70f511d3f68ec",
  "readme": "# ShareDB\n\n  [![NPM Version](https://img.shields.io/npm/v/sharedb.svg)](https://npmjs.org/package/sharedb)\n  [![Build Status](https://travis-ci.org/share/sharedb.svg?branch=master)](https://travis-ci.org/share/sharedb)\n  [![Coverage Status](https://coveralls.io/repos/github/share/sharedb/badge.svg?branch=master)](https://coveralls.io/github/share/sharedb?branch=master)\n\nShareDB is a realtime database backend based on [Operational Transformation\n(OT)](https://en.wikipedia.org/wiki/Operational_transformation) of JSON\ndocuments. It is the realtime backend for the [DerbyJS web application\nframework](http://derbyjs.com/).\n\nFor questions, discussion and announcements, join the [ShareJS mailing\nlist](https://groups.google.com/forum/?fromgroups#!forum/sharejs).\n\nPlease report any bugs you find to the [issue\ntracker](https://github.com/share/sharedb/issues).\n\n\n## Features\n\n- Realtime synchronization of any JSON document\n- Concurrent multi-user collaboration\n- Synchronous editing API with asynchronous eventual consistency\n- Realtime query subscriptions\n- Simple integration with any database - [MongoDB](https://github.com/share/sharedb-mongo)\n- Horizontally scalable with pub/sub integration - [Redis](https://github.com/share/sharedb-redis-pubsub)\n- Projections to select desired fields from documents and operations\n- Middleware for implementing access control and custom extensions\n- Ideal for use in browsers or on the server\n- Reconnection of document and query subscriptions\n- Offline change syncing upon reconnection\n- In-memory implementations of database and pub/sub for unit testing\n\n\n## Quick tour\n\n```js\nvar ShareDB = require('sharedb');\nvar db = require('sharedb-mongo')('localhost:27017/test');\n\nvar backend = ShareDB({db: db});\nvar connection = backend.connect();\n\n// Subscribe to any database query\nvar query = connection.createSubscribeQuery('users', {accountId: 'acme'});\n\nquery.once('ready', function() {\n  // Initially matching documents\n  console.log(query.results);\n});\nquery.on('insert', function(docs, index) {\n  // Documents that now match the query\n  console.log(docs);\n});\nquery.on('remove', function(docs, index) {\n  // Documents that no longer match the query\n  console.log(docs);\n});\nquery.on('move', function(docs, from, to) {\n  // Documents that were moved in the results order for sorted queries\n  console.log(docs);\n});\n\n// Create and modify documents with synchronously applied operations\nvar doc = connection.get('users', 'jane');\ndoc.create({accountId: 'acme', name: 'Jane'});\ndoc.submitOp({p: ['email'], oi: 'jane@example.com'});\n\n// Create multiple concurrent connections to the same document for\n// collaborative editing by multiple clients\nvar connection2 = backend.connect();\nvar doc2 = connection2.get('users', 'jane');\n\n// Subscribe to documents directly as well as through queries\ndoc2.subscribe(function(err) {\n  // Current document data\n  console.log(doc2.data);\n});\ndoc2.on('op', function(op, source) {\n  // Op that changed the document\n  console.log(op);\n  // truthy if submitted locally and `false` if from another client\n  console.log(source);\n});\n```\n\n## Data model\n\nIn ShareDB's view of the world, every document has 3 properties:\n\n- **version** - An incrementing number starting at 0\n- **type** - An OT type. OT types are defined in\n[share/ottypes](https://github.com/share/ottypes). Documents\nwhich don't exist implicitly have a type of `null`.\n- **data** - The actual data that the document contains. This must be pure\nacyclic JSON. Its also type-specific. (JSON type uses raw JSON, text documents\nuse a string, etc).\n\nShareDB implicitly has a record for every document you can access. New documents\nhave version 0, a null type and no data. To use a document, you must first\nsubmit a *create operation*, which will set the document's type and give it\ninitial data. Then you can submit editing operations on the document (using\nOT). Finally you can delete the document with a delete operation. By\ndefault, ShareDB stores all operations forever - nothing is truly deleted.\n\n\n## Operations\n\nSee https://github.com/ottypes/json0 for documentation of the supported operations.\n\n\n<!-- Old docs from LiveDB:\n\n## Using ShareDB\n\n### Creating documents\n\nTo create a document, you need to submit a create operation to the\ndocument to set its type. In sharedb's world, a document doesn't exist until it\nhas a type set.\n\nA create operation looks like this: `{create:{type:TYPE, [data:INITIAL DATA]}, [v:VERSION]}`. The type should be something accessible in the map returned by require('ottypes'), for example `json0` or `http://sharejs.org/types/textv1`. Specifying initial data is optional. If provided, it is passed to the type's `create()` method. This does what you expect - for JSON documents, pass your initial object here. For text documents, pass a string containing the document's contents. As with all operations, the version is optional. You probably don't want to specify the version for a create message.\n\nTo submit any changes to documents, you use `sharedb.submit(cName, docName, opData, callback)`.\n\nFor example:\n\n```javascript\nsharedb.submit('users', 'fred', {create:{type:'json0', data:[1,2,3]}}, function(err, version, transformedByOps, snapshot) {\n  // I made a document, ma!\n});\n```\n\nSince documents implicitly exist with no type at version 0, usually the create\nmessage will increment the version from 0 to 1. Not all documents you want to\ndelete have a version of 0 - if a document is deleted, it will retain its\nversion.\n\n### Deleting documents\n\nDeleting documents is similar to creating them. A deleted document has no type\nand no data, but will retain its version (actually, the delete operation will\nbump the document's version). A delete operation looks like this:\n`{del:true, [v:VERSION]}`.\n\nYou use the same submit function as above to delete documents:\n\n```javascript\nsharedb.submit('users', 'fred', {del:true}, function(err) {\n  //goneskies! Kapow!\n});\n```\n\n### Editing documents\n\nYou edit a document by submitting an operation. Operations are OT type-specific\nJSON blobs. Refer to the documentation on the particular OT type for details.\nFor example, text documents are documented\n[here](https://github.com/share/ottypes/blob/master/lib/text.js#L10-L16). If we\nhad a text document stored in LiveDB and wanted to edit it, it might look like\nthis:\n\n```javascript\nsharedb.submit('love letters', 'dear fred', {op:[6, \"You never return my calls!\"], v:1002}, function(err) {\n  // ...\n});\n```\n\nYou should always specify the version when submitting edit operations. The\nversion is technically optional - if its missing, your operation will be\nsubmitted against the most recent version of the document in the server. This\nis useful for creating a document which may already exist, but for normal edits\nyou should always specify the expected current version of the document.\n\n\n### Getting a document\n\nYou can fetch the most recent version of a document using `sharedb.fetch(cName, docName, callback)` or\n`sharedb.bulkFetch(request, callback)`. This will fetch the document(s) from the snapshot database\nand fetch all operations which may or may not have been committed.\n\nFetch returns a snapshot data object via its callback. The snapshot data object\nhas the following fields:\n\n- **v:** version. This is an integer (starting at 0) containing the version of the document\n- **type:** Document type, if set. This field is missing if the document does not exist.\n- **data:** The document's actual data. For JSON documents this is a JSON tree.\n  For text documents this is a string. This field is missing if the document does not exist.\n\n```javascript\nsharedb.fetch('users', 'fred', function(err, snapshot) {\n  // snapshot has {v:123, type:'...', data:{name:'Fred Flintstone'}}\n  // If the document doesn't exist, only the v:version field will exist in the data.\n});\n```\n\nIf you need to get many documents, its more efficient to issue bulk fetches. To\npass the set of requested documents to bulkFetch, you need to make a request\nobject which maps collection names to lists of documents you want in that\ncollection. For example, to get 'red', 'green' and 'blue' from the colors\ncollection, you would make a bulkFetch request of `{colors:['red', 'green',\n'blue']}`.\n\nThe response maps each collection name to a set of snapshots. Each set of\nsnapshots maps document names to snapshot data objects. Continuing our colors\nexample above, the response could be `{colors:{red:{v:0}, green:{v:10, type:..., data:\"emerald\"}, blue:{v:1, type:..., data:{favorite:true}}}}`.\n\nFor example:\n\n```javascript\nsharedb.bulkFetch({users:['fred', 'wilma', 'homer'], admins:['zerocool']}, function(err, results) {\n  // results will be {users:{fred:..., wilma:..., homer:...}, admins:{zerocool:...}}.\n  // Each document has v and optional type and data fields like fetch (above).\n});\n```\n\n\n### Getting historic changes to a document\n\nYou can get old versions of a document (for playback or catching up a client)\nusing `sharedb.getOps(cName, docName, from, to, callback)`. This will return\nall operations which have been applied to the named document in the requested range.\nThe range is *open*, so `getOps('users', 'fred', 0, 3, ..)` will return all\noperations up to (but not including) 3. (Ie, operations 0, 1 and 2).\n\nIf you set the *to* field to null, getOps will get all operations up to the\ncurrent version.\n\nShareDB documents always start at version 0, so you can get a document's entire history using `getOps('users', fred', 0, null, callback);`.\n\nIf you set *to* to a version in the future, behaviour is not defined.\n\nExample usage:\n\n```javascript\nsharedb.submit('users', 'fred', {create:{type:'json0', data:{name:'Fred'}}}, function(err) {\n  sharedb.submit('users', 'fred', {v:1, op:[{p:['name', 4], si:' Flintstone'}]}, function(err) {\n    // ...\n  });\n});\n\n// Sometime later...\n\nsharedb.getOps('users', 'fred', 0, null, function(err, ops) {\n  // ops contains the two operations which were submitted above:\n  // [{v:0, create:{...}, {v:1, op:[...]}]\n});\n```\n\n### Streaming changes to a document in realtime\n\nYou can subscribe to changes from a document using\n`sharedb.subscribe(cName, docName, v, callback)` or\n`sharedb.bulkSubscribe(request, callback)`. When you subscribe, you get an\noperation stream which gets packed with operations as they happen.\n\nWhen you subscribe to a document, you need to specify which version you're\nsubscribing to the document *from*. The version cannot be in the future.\n\nThe stream will be populated with each operation from the requested version\nonwards (to infinity and beyond). Each operation will appear in the stream\nexactly once. If you subscribe and request an old document version, all\noperations from that version to the current version will be buffered in the\nstream before the stream is returned to the callback.\n\nYou usually want to call *subscribe* after fetching a document. Pass the\ndocument version that you got from calling *fetch* into your call to\n*subscribe*.\n\nFor example:\n\n```javascript\nsharedb.fetch('users', 'fred', function(err, data) {\n  if (err) { ... }\n  var version = data.v;\n\n  // ... Any amount of time later (literally).\n  sharedb.subscribe('users', 'fred', version, function(err, stream) {\n    if (err) { ... }\n\n    // stream is a nodejs ReadableStream with all operations that happen to\n    // users.fred.\n\n    stream.on('data', function(opData) {\n      // The opData is a JSON object, the same object you can pass to submit().\n      // It always has a v: field.\n\n      // ShareDB exports a helper function to apply the operation to some\n      // snapshot data:\n      var err = ldb.ot.apply(data, opData);\n      if (err) { ... }\n    });\n  });\n});\n```\n\n**Important!** To avoid leaking memory, when you're done with a stream call `stream.destroy()` to clean it up.\n\nThere is a helper method which will both fetch and subscribe for you (cleverly\ncalled `fetchAndSubscribe(cName, docName, callback)`). It is defined like this:\n\n```javascript\nShareDB.prototype.fetchAndSubscribe = function(cName, docName, callback) {\n  var self = this;\n  this.fetch(cName, docName, function(err, data) {\n    if (err) return callback(err);\n    self.subscribe(cName, docName, data.v, function(err, stream) {\n      callback(err, data, stream);\n    });\n  });\n};\n```\n\nIt calls your callback with `(err, snapshot, stream)`, giving you both the current document snapshot and the stream of operations from the current version.\n\n#### Bulk Subscribe\n\nIf you want to subscribe to multiple documents at once, you should call\n`bulkSubscribe(request, callback)`. The bulk subscribe request is a map from\ncName -> map from docName -> version. For example, `{colors: {red:5, blue:6,\ngreen:0}}`. The response is a map from cName -> map from docName -> stream.\nFor example, `{colors: {red:<stream>, blue:<stream>, green:<stream>}}`.\nbulkSubscribe will either return a stream for all requested objects or (if\nthere was an error), none of them.\n\nAgain, remember to call `stream.destroy()` on all streams returned by bulk\nsubscribe when you're done with them.\n\n\n### Queries\n\nShareDB supports running live queries against the database. It can re-run queries when it suspects that a query's results might have changed - and notify the caller with any changes to the result set.\n\nThis is incredibly inefficient and I want to completely rewrite / rework them. For now, I recommend against using live bound queries in a production app with a decent load. I'll document them when I'm happier with them.\n\n\n### Projections\n\nShareDB supports exposing a *projection* of a real collection, with a specified\n(limited) set of allowed fields. Once configured, the projected collection\nlooks just like a real collection - except documents only have the fields\nyou've requested.\n\nOperations (gets, queries, sets, etc) on the fake collection work, but you only\nsee a small portion of the data. You can use this to drop server & db load\ndramatically and speed up page times. Its similar to SQL VIEWs. For now, this\nonly works on JSON documents. (I don't know what it would look like for text\ndocuments).\n\nFor example, you could make a `users_limited` projection which lets users view\neach other's names and profile pictures, but not password hashes. You would\nconfigure this by calling:\n\n```javascript\nsharedb.addProjection('users_limited', 'users', 'json0', {name:true, profileUrl:true});\n```\n\nHowever, be aware that on its own **this is not sufficient for access control**. If\nusers are still allowed to make arbitrary mongo queries against the projected\ncollection, they can find out any data in the hidden fields.\n\nConfigure a projection by calling `addProjection(projCName, realCName, type, fields)`.\n\n- **projCName:** The projected collection name. (Eg, `users_limited`)\n- **realCName:** The underlying collection name\n- **type:** The OT type. Only JSON0 is supported for now.\n- **fields:** A map of the allowed fields in documents. The keys in this map\n  represent the field names, and the values should be `true`.\n\nLimitations:\n\n- You can only whitelist fields (not blacklist them).\n- Projections can only limit / allow fields at the top level of the document\n\n## Error codes\n\nShareDB returns errors as plain JavaScript objects with the format:\n```\n{\n  code: 5000,\n  message: 'ShareDB internal error'\n}\n```\n\nAdditional fields may be added to the error object for debugging context depending on the error. Common additional fields include `collection`, `id`, and `op`.\n\n### 4000 - Bad request\n\n* 4001 -\n\n### 5000 - Internal error\n\nThe `41xx` and `51xx` codes are reserved for use by ShareDB DB adapters, and the `42xx` and `52xx` codes are reserved for use by ShareDB PubSub adapters.\n\n* 5001 - No new ops returned when retrying unsuccessful submit\n\n-->\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/FTAndy/sharedb/issues"
  },
  "homepage": "https://github.com/FTAndy/sharedb",
  "_id": "sharedb@0.11.35",
  "_shasum": "8dbc6d6af3fc2b4a2ff791ea47c120cf87aa7805",
  "_from": "git://github.com/FTAndy/sharedb.git",
  "_resolved": "git://github.com/FTAndy/sharedb.git#c28a1c233ab3a278edb144da27c70f511d3f68ec",
  "_fromGithub": true
}
